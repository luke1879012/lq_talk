今天我分享的主题是Python的列表，我们主要从两方面来研究
* 为什么Python列表可以随便放任意类型的数据？
* Python列表是如何自动扩容的？

总所周知，Python的解释器是由C语言写的，C语言中也有类似于列表的结构，叫数组。
数组有个两个致命缺陷，只支持同一类型，使用前需要声明容量。
python针对数组只支持同一个类型的缺陷，在底层统一了类型，这样就可以用数组来当做列表。
这个统一的类型就叫做PyObject结构体，Python中所有对象都由这个类型来。（Python的祖宗）（看一下图片）
但是这样会有一个问题，存入列表之前，我们是知道这个是int类型，存入之后，都变成了PyObject了，我们怎么还原？
因此PyObject结构体里面多了一个字段，ob_type。我们可以根据这个字段来转换回来。（看一下图片）

但是这样做的后果导致程序每次处理数据，都需要多了一个层用于判断数据的类型，
因此导致Python的运行速度变慢了，
下次面试的时候，问到Python为什么慢的时候，别再说全局解释器锁（GIL）了，那是在并发的时候才有限制

现在知道了，Python列表可以存放任何东西，是因为底层统一了类型PyObject，列表里面存的是PyObject指针

接着解决第二个：自动扩容，刚开始说了C语言只能你提前说明需要多大容量的数组，然后再给你分配
Python解决方案是每次多申请一点，等你把多申请的容量用完了，再申请更大的数组，将数据复制到新数组，丢弃旧数组（看图）
因此Python多了一个字段来标记最大容量，allocated。也就是Python的列表有两个容量，一个是保存当前数组长度，另一个保存最大容量

但是这个新数组需要申请多大呢？如果申请多了，浪费内存，申请少了，一下次就存满了，经常需要转移数据，费时费力。
我们去看看源码
1. 介绍`PyListObject`结构体
2. 用Python实现结构体
3. Python实例化一个，得知每个字段的值（去`例子.py`看一看）

看看append函数的实现，因为它的实现比较简单
1. 判断是否扩容
2. 增加引用计数
3. 设置到对应位置

运行代码校验一下

最终源代码回顾

最后，我来总结一下，底层用PyObject结构体实现了存放任意类型数据，
知道了Python运行速度慢的原因之一是每次操作都需要做类型判断。
了解了列表的底层结构，通过增加一个最大容量的allocated字段，配合扩容公式，实现了自动扩容。
我的分享就到这里，谢谢大家


